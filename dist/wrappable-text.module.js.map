{"version":3,"file":"wrappable-text.module.js","sources":["../index.js"],"sourcesContent":["import LineBreaker from '@craigmorton/linebreak'\n\nconst BR = '\\u000A'\nconst NBSP = '\\u00A0'\nconst SHY = '\\u00AD'\nconst ZWSP = '\\u200B'\n\nfunction monospace (string) { return string.length }\nfunction getBreaks (string) {\n  const breaker = new LineBreaker(string)\n  const breaks = {}\n\n  while (true) {\n    const br = breaker.nextBreak()\n    if (!br) break\n    breaks[br.position] = br\n  }\n\n  return breaks\n}\n\nexport default class WrappableText {\n  constructor (value, {\n    measure = monospace,\n    br = BR,\n    nbsp = NBSP,\n    shy = SHY,\n    zwsp = ZWSP\n  } = {}) {\n    this.measure = measure\n    this.value = value\n      .replace(new RegExp(br, 'g'), BR)\n      .replace(new RegExp(nbsp, 'g'), NBSP)\n      .replace(new RegExp(shy, 'g'), SHY)\n      .replace(new RegExp(zwsp, 'g'), ZWSP)\n  }\n\n  get isEmpty () {\n    return !this.value\n      .replace(/\\s/g, '')\n      .replace(new RegExp(BR, 'g'), '')\n      .replace(new RegExp(NBSP, 'g'), '')\n      .replace(new RegExp(SHY, 'g'), '')\n      .replace(new RegExp(ZWSP, 'g'), '')\n  }\n\n  wrap (width = Number.POSITIVE_INFINITY) {\n    const lines = []\n    const breaks = getBreaks(this.value)\n\n    let start = 0\n    while (start < this.value.length) {\n      let curr = start\n      let lineWidth = 0\n      while (curr < this.value.length) {\n        // Handle required breaks\n        if (breaks[curr] && breaks[curr].required && !breaks[curr].consumed) {\n          breaks[curr].consumed = true\n          curr--\n          break\n        }\n\n        // Build the line\n        lineWidth += this.measure(this.value.charAt(curr))\n\n        // When the line starts overflowing, find the nearest break before the\n        // cursor, break there and restart from this position\n        if (lineWidth >= width) {\n          const br = Object.values(breaks)\n            .reverse()\n            .find(({ position, consumed }) => !consumed && curr > position)\n\n          if (br) {\n            br.consumed = true\n            curr = br.position\n            break\n          }\n        }\n\n        // Advance one char\n        curr++\n      }\n\n      // Ensure all previous breaks have been consumed\n      for (const i in breaks) {\n        if (i > curr) continue\n        if (breaks[i]) breaks[i].consumed = true\n      }\n\n      // Get the line value\n      let value = this.value.substring(start, curr).trim()\n\n      // Handle shy\n      if (this.value.charAt(curr - 1) === SHY) value += '-'\n      value = value.replace(SHY, '')\n\n      lines.push({ value, width: this.measure(value) })\n      start = curr\n    }\n\n    return {\n      lines,\n      overflow: !!lines.find(line => line.width > width)\n    }\n  }\n\n  nowrap (width = Number.POSITIVE_INFINITY) {\n    const value = this.value\n      .replace(new RegExp(BR, 'g'), '')\n      .replace(new RegExp(NBSP, 'g'), '')\n      .replace(new RegExp(SHY, 'g'), '')\n      .replace(new RegExp(ZWSP, 'g'), '')\n    const lineWidth = this.measure(value)\n\n    // We use the same object structure as WrappableText.wrap() so that both\n    // methods can be used interchangeably\n    return {\n      lines: [{ value, width: lineWidth }],\n      overflow: lineWidth > width\n    }\n  }\n}\n"],"names":["monospace","string","length","WrappableText","value","measure","br","nbsp","shy","zwsp","this","replace","RegExp","wrap","width","Number","POSITIVE_INFINITY","lines","breaks","breaker","LineBreaker","nextBreak","position","getBreaks","start","curr","lineWidth","_this","required","consumed","charAt","Object","values","reverse","find","i","substring","trim","push","overflow","line","nowrap"],"mappings":"sCAOA,SAASA,EAAWC,GAAU,OAAOA,EAAOC,OAcvBC,IAAAA,0BACnB,WAAaC,sBAMT,SALFC,YACAC,GAAAA,aAtBO,WAuBPC,KAAAA,aAtBS,UAuBTC,IAAAA,aAtBQ,UAuBRC,KAAAA,aAtBS,MAwBTC,KAAKL,mBANKL,IAOVU,KAAKN,MAAQA,EACVO,QAAQ,IAAIC,OAAON,EAAI,KA7BnB,MA8BJK,QAAQ,IAAIC,OAAOL,EAAM,KA7BnB,KA8BNI,QAAQ,IAAIC,OAAOJ,EAAK,KA7BnB,KA8BLG,QAAQ,IAAIC,OAAOH,EAAM,KA7BnB,kCAyCXI,KAAA,SAAMC,uBAAAA,IAAAA,EAAQC,OAAOC,mBAKnB,IAJA,IAAMC,EAAQ,GACRC,EAxCV,SAAoBjB,GAIlB,IAHA,IAAMkB,EAAU,IAAIC,EAAYnB,GAC1BiB,EAAS,KAEF,CACX,IAAMZ,EAAKa,EAAQE,YACnB,IAAKf,EAAI,MACTY,EAAOZ,EAAGgB,UAAYhB,EAGxB,OAAOY,EA8BUK,CAAUb,KAAKN,OAE1BoB,EAAQ,eAIV,IAFA,IAAIC,EAAOD,EACPE,EAAY,EACTD,EAAOE,EAAKvB,MAAMF,QAAQ,CAE/B,GAAIgB,EAAOO,IAASP,EAAOO,GAAMG,WAAaV,EAAOO,GAAMI,SAAU,CACnEX,EAAOO,GAAMI,UAAW,EACxBJ,IACA,MAQF,IAJAC,GAAaC,EAAKtB,QAAQsB,EAAKvB,MAAM0B,OAAOL,MAI3BX,EAAO,CACtB,IAAMR,EAAKyB,OAAOC,OAAOd,GACtBe,UACAC,KAAK,qBAAaL,UAA4BJ,IAAtCH,WAEX,GAAIhB,EAAI,CACNA,EAAGuB,UAAW,EACdJ,EAAOnB,EAAGgB,SACV,OAKJG,IAIF,IAAK,IAAMU,KAAKjB,EACViB,EAAIV,GACJP,EAAOiB,KAAIjB,EAAOiB,GAAGN,UAAW,GAItC,IAAIzB,EAAQuB,EAAKvB,MAAMgC,UAAUZ,EAAOC,GAAMY,OAtFxC,MAyFFV,EAAKvB,MAAM0B,OAAOL,EAAO,KAAYrB,GAAS,KAClDA,EAAQA,EAAMO,QA1FR,IA0FqB,IAE3BM,EAAMqB,KAAK,CAAElC,MAAAA,EAAOU,MAAOa,EAAKtB,QAAQD,KACxCoB,EAAQC,GA9CHD,EAAQd,KAAKN,MAAMF,YAiD1B,MAAO,CACLe,MAAAA,EACAsB,WAAYtB,EAAMiB,KAAK,SAAAM,UAAQA,EAAK1B,MAAQA,QAIhD2B,OAAA,SAAQ3B,YAAAA,IAAAA,EAAQC,OAAOC,mBACrB,IAAMZ,EAAQM,KAAKN,MAChBO,QAAQ,IAAIC,OA1GR,KA0GmB,KAAM,IAC7BD,QAAQ,IAAIC,OA1GN,IA0GmB,KAAM,IAC/BD,QAAQ,IAAIC,OA1GP,IA0GmB,KAAM,IAC9BD,QAAQ,IAAIC,OA1GN,IA0GmB,KAAM,IAC5Bc,EAAYhB,KAAKL,QAAQD,GAI/B,MAAO,CACLa,MAAO,CAAC,CAAEb,MAAAA,EAAOU,MAAOY,IACxBa,SAAUb,EAAYZ,2BAjF1B,WACE,OAAQJ,KAAKN,MACVO,QAAQ,MAAO,IACfA,QAAQ,IAAIC,OAtCR,KAsCmB,KAAM,IAC7BD,QAAQ,IAAIC,OAtCN,IAsCmB,KAAM,IAC/BD,QAAQ,IAAIC,OAtCP,IAsCmB,KAAM,IAC9BD,QAAQ,IAAIC,OAtCN,IAsCmB,KAAM"}