{"version":3,"file":"wrappable-text.modern.js","sources":["../index.js"],"sourcesContent":["import LineBreaker from '@craigmorton/linebreak'\n\nconst BR = '\\u000A'\nconst NBSP = '\\u00A0'\nconst SHY = '\\u00AD'\nconst ZWSP = '\\u200B'\n\nfunction monospace (string) { return string.length }\nfunction getBreaks (string) {\n  const breaker = new LineBreaker(string)\n  const breaks = {}\n\n  while (true) {\n    const br = breaker.nextBreak()\n    if (!br) break\n    breaks[br.position] = br\n  }\n\n  return breaks\n}\n\nexport default class WrappableText {\n  constructor (value, {\n    measure = monospace,\n    br = BR,\n    nbsp = NBSP,\n    shy = SHY,\n    zwsp = ZWSP\n  } = {}) {\n    this.measure = measure\n    this.value = value\n      .replace(new RegExp(br, 'g'), BR)\n      .replace(new RegExp(nbsp, 'g'), NBSP)\n      .replace(new RegExp(shy, 'g'), SHY)\n      .replace(new RegExp(zwsp, 'g'), ZWSP)\n  }\n\n  get isEmpty () {\n    return !this.value\n      .replace(/\\s/g, '')\n      .replace(new RegExp(BR, 'g'), '')\n      .replace(new RegExp(NBSP, 'g'), '')\n      .replace(new RegExp(SHY, 'g'), '')\n      .replace(new RegExp(ZWSP, 'g'), '')\n  }\n\n  wrap (width = Number.POSITIVE_INFINITY) {\n    const lines = []\n    const breaks = getBreaks(this.value)\n\n    let start = 0\n    while (start < this.value.length) {\n      let curr = start\n      let lineWidth = 0\n      while (curr < this.value.length) {\n        // Handle required breaks\n        if (breaks[curr] && breaks[curr].required && !breaks[curr].consumed) {\n          breaks[curr].consumed = true\n          curr--\n          break\n        }\n\n        // Build the line\n        lineWidth += this.measure(this.value.charAt(curr))\n\n        // When the line starts overflowing, find the nearest break before the\n        // cursor, break there and restart from this position\n        if (lineWidth >= width) {\n          const br = Object.values(breaks)\n            .reverse()\n            .find(({ position, consumed }) => !consumed && curr > position)\n\n          if (br) {\n            br.consumed = true\n            curr = br.position\n            break\n          }\n        }\n\n        // Advance one char\n        curr++\n      }\n\n      // Ensure all previous breaks have been consumed\n      for (const i in breaks) {\n        if (i > curr) continue\n        if (breaks[i]) breaks[i].consumed = true\n      }\n\n      // Get the line value\n      let value = this.value.substring(start, curr).trim()\n\n      // Handle shy\n      if (this.value.charAt(curr - 1) === SHY) value += '-'\n      value = value.replace(SHY, '')\n\n      lines.push({ value, width: this.measure(value) })\n      start = curr\n    }\n\n    return {\n      lines,\n      overflow: !!lines.find(line => line.width > width)\n    }\n  }\n\n  nowrap (width = Number.POSITIVE_INFINITY) {\n    const value = this.value\n      .replace(new RegExp(BR, 'g'), '')\n      .replace(new RegExp(NBSP, 'g'), '')\n      .replace(new RegExp(SHY, 'g'), '')\n      .replace(new RegExp(ZWSP, 'g'), '')\n    const lineWidth = this.measure(value)\n\n    // We use the same object structure as WrappableText.wrap() so that both\n    // methods can be used interchangeably\n    return {\n      lines: [{ value, width: lineWidth }],\n      overflow: lineWidth > width\n    }\n  }\n}\n"],"names":["monospace","string","length","WrappableText","constructor","value","measure","br","nbsp","shy","zwsp","this","replace","RegExp","isEmpty","wrap","width","Number","POSITIVE_INFINITY","lines","breaks","breaker","LineBreaker","nextBreak","position","getBreaks","start","curr","lineWidth","required","consumed","charAt","Object","values","reverse","find","i","substring","trim","push","overflow","line","nowrap"],"mappings":"sCAOA,SAASA,EAAWC,GAAU,OAAOA,EAAOC,aAcvBC,EACnBC,YAAaC,GAAOC,QAClBA,EAAUN,EADQO,GAElBA,EAtBO,KAoBWC,KAGlBA,EAtBS,IAmBSC,IAIlBA,EAtBQ,IAkBUC,KAKlBA,EAtBS,KAuBP,IACFC,KAAKL,QAAUA,EACfK,KAAKN,MAAQA,EACVO,QAAQ,IAAIC,OAAON,EAAI,KA7BnB,MA8BJK,QAAQ,IAAIC,OAAOL,EAAM,KA7BnB,KA8BNI,QAAQ,IAAIC,OAAOJ,EAAK,KA7BnB,KA8BLG,QAAQ,IAAIC,OAAOH,EAAM,KA7BnB,KAgCPI,cACF,OAAQH,KAAKN,MACVO,QAAQ,MAAO,IACfA,QAAQ,IAAIC,OAtCR,KAsCmB,KAAM,IAC7BD,QAAQ,IAAIC,OAtCN,IAsCmB,KAAM,IAC/BD,QAAQ,IAAIC,OAtCP,IAsCmB,KAAM,IAC9BD,QAAQ,IAAIC,OAtCN,IAsCmB,KAAM,IAGpCE,KAAMC,EAAQC,OAAOC,mBACnB,MAAMC,EAAQ,GACRC,EAxCV,SAAoBnB,GAClB,MAAMoB,EAAU,IAAIC,EAAYrB,GAC1BmB,EAAS,GAEf,OAAa,CACX,MAAMb,EAAKc,EAAQE,YACnB,IAAKhB,EAAI,MACTa,EAAOb,EAAGiB,UAAYjB,EAGxB,OAAOa,EA8BUK,CAAUd,KAAKN,OAE9B,IAAIqB,EAAQ,EACZ,KAAOA,EAAQf,KAAKN,MAAMH,QAAQ,CAChC,IAAIyB,EAAOD,EACPE,EAAY,EAChB,KAAOD,EAAOhB,KAAKN,MAAMH,QAAQ,CAE/B,GAAIkB,EAAOO,IAASP,EAAOO,GAAME,WAAaT,EAAOO,GAAMG,SAAU,CACnEV,EAAOO,GAAMG,UAAW,EACxBH,IACA,MAQF,GAJAC,GAAajB,KAAKL,QAAQK,KAAKN,MAAM0B,OAAOJ,IAIxCC,GAAaZ,EAAO,CACtB,MAAMT,EAAKyB,OAAOC,OAAOb,GACtBc,UACAC,KAAK,EAAGX,SAAAA,EAAUM,SAAAA,MAAgBA,GAAYH,EAAOH,GAExD,GAAIjB,EAAI,CACNA,EAAGuB,UAAW,EACdH,EAAOpB,EAAGiB,SACV,OAKJG,IAIF,IAAK,MAAMS,KAAKhB,EACVgB,EAAIT,GACJP,EAAOgB,KAAIhB,EAAOgB,GAAGN,UAAW,GAItC,IAAIzB,EAAQM,KAAKN,MAAMgC,UAAUX,EAAOC,GAAMW,OAtFxC,MAyFF3B,KAAKN,MAAM0B,OAAOJ,EAAO,KAAYtB,GAAS,KAClDA,EAAQA,EAAMO,QA1FR,IA0FqB,IAE3BO,EAAMoB,KAAK,CAAElC,MAAAA,EAAOW,MAAOL,KAAKL,QAAQD,KACxCqB,EAAQC,EAGV,MAAO,CACLR,MAAAA,EACAqB,WAAYrB,EAAMgB,KAAKM,GAAQA,EAAKzB,MAAQA,IAIhD0B,OAAQ1B,EAAQC,OAAOC,mBACrB,MAAMb,EAAQM,KAAKN,MAChBO,QAAQ,IAAIC,OA1GR,KA0GmB,KAAM,IAC7BD,QAAQ,IAAIC,OA1GN,IA0GmB,KAAM,IAC/BD,QAAQ,IAAIC,OA1GP,IA0GmB,KAAM,IAC9BD,QAAQ,IAAIC,OA1GN,IA0GmB,KAAM,IAC5Be,EAAYjB,KAAKL,QAAQD,GAI/B,MAAO,CACLc,MAAO,CAAC,CAAEd,MAAAA,EAAOW,MAAOY,IACxBY,SAAUZ,EAAYZ"}